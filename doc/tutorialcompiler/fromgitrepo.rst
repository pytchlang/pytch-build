Compiling a tutorial from a Git repository
==========================================

Usage
-----

Create a ``git`` repo with a particular structure.  TODO: Move
description from Google doc into here.  Run the command-line tool to
produce a zipfile of the tutorial html bundle and the project assets.
Unzip into the web content directory.

Currently, such a tutorial is produced from a *git repository* which
develops the project in a readable fashion.  The Python code lives in
a file called ``code.py``, and the tutorial text lives in a file
called ``tutorial.md``

Command-line compiler
^^^^^^^^^^^^^^^^^^^^^

Example::

  pytchbuild -o /tmp/bunner.zip

In general, ``pytchbuild`` can be told:

* which git repository to use; by default, the one containing the
  working directory, or as specified by the ``GIT_DIR`` environment
  variable (TODO: which takes precedence?);

* which revision is the tip of the tutorial; by default, ``HEAD``.

* whether to use the current working directory's version of the
  tutorial text markdown file (or use the default, which is the
  content as of the tip revision).

Typical development workflow, then, is to be working in the
``pytch-tutorials`` repo on a branch named for your tutorial.  When
ready to try the tutorial in the IDE, run something like::

  pytchbuild -o /tmp/t.zip \
    && unzip -d ../pytch-ide/example/pytch/tutorials -o /tmp/t.zip

TODO: Integrate this into a completely automated build of website.


Structure of git repo
---------------------

Each tutorial should be its own branch of the repo, and work within
its own top-level directory of the repo.  We imagine such branches
will very often have their history re-written as we think of clearer
ways of structuring the development of the code.

I think it will be possible to have the ``releases`` branch have
octopus merges in from the different tutorial branches, with the main
parent commit being the previous bundle of tutorials.  But I haven't
looked into this in detail yet.

One downside: it would make it more annoying to have a simple overview
of all available tutorials within the working directory.  Could have a
‘release new version of Boing’ commit to ``releases``, which brings in
the latest history?  Old histories would then still be available as
parents of older ``releases`` commits?  Needs more thought.

Elsewhere I've experimented with *structured* git repos, but for Pytch
tutorials we're trying a different approach, where the structure
(decomposition into sections etc.) is provided by the ``tutorial.md``
document rather than the repo structure itself.  (Although there's
nothing to stop the author creating a ‘dual-use’ history, where the
history is structured as organised repo (merge commits for sections)
for use with pure git tools, and also suitable for being rendered
together with its ``tutorial.md`` into a bundle for the webapp.)

To identify particular commits touching the ``code.py`` file, the
author adds a *slug* to the commit message by starting the subject
with a string like::

  {#fire-alien-missile}

To refer to such a commit in the tutorial text, and bring in an
interactive patch element to the presentation, the author writes a
paragraph consisting of just a particular *shortcode* into the
``tutorial.md`` file like::

  {{< commit fire-alien-missile >}}

(These shortcodes are modelled on Hugo's.)


Structure of tutorial markdown file
-----------------------------------

Consists of *front matter* followed by *chapters*.

Front matter
^^^^^^^^^^^^

Start with level-1 heading naming the project.  Then whatever you
like, then a horizonal rule.  The rule marks the end of the front
matter and does not appear in the rendered tutorial.

TODO: Should this include metadata (author, licence, acknowledgements,
abstract)?  That could go between initial H1 and the start of the
tutorial proper.

Typically the rendered front matter will include a *try the project*
button, which is generated by the shortcode::

  {{< run-finished-project >}}


Chapters
^^^^^^^^

After the horizontal rule, the markdown file should contain the
*chapters* of the tutorial.  Each chapter starts with a level-2
heading and continues until either the next level-2 heading or the end
of the file.  Within each chapter, level-3 or lower-level headings can
be used, as can any other markdown features

Showing patches
~~~~~~~~~~~~~~~

At a point where the tutorial wants to show the exact change to the
code required to do the next step of the project, the author can write
a paragraph consisting of a ``commit`` shortcode::

  {{< commit fire-alien-missile >}}

The compiler transforms this into a ``<div>`` with a particular
structure which can be picked up by the front end, to add
interactivity features.

(Currently the complete text of the ``code.py`` file as of that commit
is included as a data attribute.  This was used for an experimental
*make mine like this* feature, but currently is unused.  It bloats the
HTML fragment considerably.  Remove it?  Recover it from the sequence
of patches?)

Project assets
~~~~~~~~~~~~~~

The project will require graphics and maybe sound assets.  These
files should be added in standard git commits.  More than one asset
can be added in a single commit, but such commits should *not* include
any other changes.

TODO: Specify a format of the commit message to include copyright and
licence, for example creative commons, source attribution, etc.
Gather these all up as part of the compiler into a *sources* or
*acknowledgments* file to be presented as part of the tutorial.

Current thinking is that assets will be added and then left
unchanged.  Is there a use-case for modifying the graphics as part of
the tutorial?  If so, how to encode version information in the code?
Connected with the general 'project namespace' or 'base url' question;
could that include a revision number?


Output from compiler
--------------------

Zipfile containing a single directory at top level, whose name is
taken from the sole directoy at top-level in the repo (as of the tip
of the branch containing that particular tutorial).  Within that
directory, the contents are:

* ``tutorial.html`` — HTML fragment suitable for loading by
  interactive tutorial mechanism in webapp.

* ``project-assets/`` — Directory containing images and/or sounds as
  required by project which the tutorial explains.  Within the
  tutorial Python, the URL is taken to refer to an object under
  ``project-assets/``.  TODO: Need some magic to set the base-url for
  the project.  Currently that’s a Skulpt-level config option; should
  it be a piece of project state (don’t think so)?  The directory
  structure in the git repo should likewise have a ‘project-assets’
  directory.

TODO: What about assets for use in the tutorial itself, e.g.,
screenshots?  Can right-click on stage and choose ‘Save image as…’ (in
Chrome anyway); choosing this gives you a ``download.png`` file.
Might be nice to automatically generate screenshots by running the
script in true Python and capturing and enacting the rendering
instructions after a specified sequence of events, but that can be
future work.  Put these in ``tutorial-assets/`` both in the repo and
the output zipfile.

TODO: This information is independent of the fact that the zipfile
came from a git repo.  Move it to the general
``tutorial-structure.rst`` file?


Tool support
------------

TODO: Script to create git repo of appropriate form.  E.g., make
empty-base branch, initial commit within nothing in it, structure with
READMEs in appropriate directories (assets), initial ``tutorial.md``
with the title as given on command line.  Cookie-cutter for this?
Branch pointing at git history once those pieces are all committed?


Internals
---------

The following is cut/paste from an earlier version of the tool and
needs revising:

We collect the tutorial into chapters; each chapter is a list of
elements.  An 'interactive patch' element gets turned into a DIV with
the relevant patch as a table, as well as extra metadata.  Each
chapter starts with an H2 and continues until either the next H2 or
the end of the whole document.


Outline design
--------------

Major pieces are:

.. py:class:: Asset

    Graphics or sound asset belonging to project

    Distinction is (or will be) against *tutorial* asset, e.g., a
    screenshot to be included in the presentation.

    Contains path (QN: relative to what?) and data-bytes.  Relative to
    git root?

.. py:class:: ProjectCommit

    Individual commit from history

    Construct from repo and commit-OID.

    Different types of commit:

    - Identified commit belonging to project being developed: Expect
      this to be used in tutorial.
    - Addition of asset/s: E.g., adding a graphics file.
    - The unique base commit: How much code should there be in this?
      Just the ``import`` stuff at the top?
    - Updates just to the raw markdown of the tutorial text: Ignored
      when generating tutorial.
    - TODO: Addition of tutorial assets, e.g., screenshots.

    .. py:attribute:: added_assets

        A list of :py:class:`Asset` instances.

        QN: A given ProjectCommit might add more than one asset.  We
        also have an explicit (but possibly redundant) tag in the
        commit message to flag a commit as adding assets.  What if the
        tag and the actual commit disagree?  Should it be possible to
        do :py:attr:`added_assets` on any :py:class:`ProjectCommit`?
        Should this return an empty list if there are no added assets?
        Emit a warning if it adds assets but doesn't include the
        ``add-project-assets`` tag (or vice versa)?  TODO: That tag is
        no longer used I think?

    .. py:attribute:: maybe_identifying_slug

        The text of the identifying slug, if one present, otherwise None.

    .. py:attribute:: is_base: bool

        Whether the commit message contains the magic 'this is the base' tag.

    .. py:attribute:: modified_tutorial_text

        Whether the commit updates just the
        :samp:`{TOP-LEVEL-DIRECTORY}/tutorial.md` file, and is not
        otherwise tagged.


.. py:class:: ProjectHistory

    Chain of git commits developing project from scratch.

    Read in repo, starting at some commit and tracing back through
    first parent until a given end commit.  Really just a list of
    `ProjectCommit` objects.

    Ctor inputs:

    - Repo directory.  Branch name with latest commit in history to
      process.  (QN: Might one day want to support more than one
      'final' branch, to support 'now you try this', or 'alternatively
      we could have implemented this feature like this.)

    - Tip revision.

    - Which source to use for the tutorial text.


.. py:class:: TutorialRawText

    Document with tutorial text and DIVs for rich content

    Read in tutorial text, break down into sections, identify pieces
    where augmentation from the git repo is required.

    Ctor inputs:

    - Filename of markdown file.

    Representation:

    Soup?  Whose job is it to manipulate the soup to add the
    attributes etc. to the DIVs for interactive commits?  And who owns
    the soup?  Probably OK for it to live in the TutorialRawText, but
    for the convention to be that when that TutorialRawText is handed
    over to the TutorialBundle ctor, the contained soup is available
    for the TutorialBundle to mutate.

.. py:class:: TutorialBundle

    Filesystem fragment (tutorial.html, assets/ directory)

    Representation of everything needed to emit the tutorial bundle:

    - Raw text (`TutorialRawText`)
    - Git repo / project history (:py:class:`ProjectHistory`)

    Constructed from the above two things.

    .. py:method:: write_zipfile(filename)



TODOs
-----

Validation and/or warnings would be nice, including:

* each project asset is added once and then left alone
* each project asset has a path within the 'project-assets/' directory
* exactly those commits tagged as adding project assets do in fact add project assets
* all changes to the code file are tagged with identifier-slugs
* all untagged commits are changes to the tutorial.md file
* there is exactly one base in the history
* the history has no merges
