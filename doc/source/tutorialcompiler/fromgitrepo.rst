Compiling a tutorial from a Git repository
==========================================

Structure of git repo
---------------------

Each tutorial is in its own branch of the repo, and has its own
top-level directory within the repo.  We imagine such branches will
very often have their history re-written as we think of clearer ways
of structuring the development of the code.

The structure of the development of the code (its decomposition into
sections etc.) is provided by the ``tutorial.md`` document.

To identify particular commits touching the ``code.py`` file, the
author adds a *slug* to the commit message by starting the subject
with a string like::

  {#fire-alien-missile}

To refer to such a commit in the tutorial text, and bring in an
interactive patch element to the presentation, the author writes a
paragraph consisting of just a particular *shortcode* into the
``tutorial.md`` file like::

  {{< commit fire-alien-missile >}}

(These shortcodes are modelled on Hugo's.)


Creating a new tutorial
-----------------------

There is an **experimental** tool for creating the necessary file and
repo structures for a new tutorial.  Within the ``pytch-tutorials``
repo, and with the ``pytchbuild`` virtual environment activated, run
something like::

  pytchbuild-new-tutorial \
    --tutorial-name="Collect the diamonds" \
    --tutorial-branch=bn/collect-diamonds-01 \
    --tutorial-slug="collect-diamonds"

Where the three inputs give the short human-readable name, the branch
name to be created, and the name of the directory to be created.


Structure of tutorial markdown file
-----------------------------------

Consists of *front matter* followed by *chapters*.

Front matter
^^^^^^^^^^^^

Start with level-1 heading naming the project.  Then whatever you
like, then a horizonal rule.  The rule marks the end of the front
matter and does not appear in the rendered tutorial.

TODO: Should this include metadata (author, licence, acknowledgements,
abstract)?  That could go between initial H1 and the start of the
tutorial proper.

Typically the rendered front matter will include a *try the project*
button, which is generated by the shortcode::

  {{< run-finished-project >}}


Chapters
^^^^^^^^

After the horizontal rule, the markdown file should contain the
*chapters* of the tutorial.  Each chapter starts with a level-2
heading and continues until either the next level-2 heading or the end
of the file.  Within each chapter, level-3 or lower-level headings can
be used, as can any other markdown features

Showing patches
~~~~~~~~~~~~~~~

At a point where the tutorial wants to show the exact change to the
code required to do the next step of the project, the author can write
a paragraph consisting of a ``commit`` shortcode::

  {{< commit fire-alien-missile >}}

The compiler transforms this into a ``<div>`` with a particular
structure which can be picked up by the front end, to add
interactivity features.

(Currently the complete text of the ``code.py`` file as of that commit
is included as a data attribute.  This was used for an experimental
*make mine like this* feature, but currently is unused.  It bloats the
HTML fragment considerably.  Remove it?  Recover it from the sequence
of patches?)

Project assets
~~~~~~~~~~~~~~

The project will require graphics and maybe sound assets.  These
files should be added in standard git commits.  More than one asset
can be added in a single commit, but such commits should *not* include
any other changes.

TODO: Specify a format of the commit message to include copyright and
licence, for example creative commons, source attribution, etc.
Gather these all up as part of the compiler into a *sources* or
*acknowledgments* file to be presented as part of the tutorial.

Current thinking is that assets will be added and then left
unchanged.  Is there a use-case for modifying the graphics as part of
the tutorial?  If so, how to encode version information in the code?
Connected with the general 'project namespace' or 'base url' question;
could that include a revision number?


Tutorial summary file
---------------------

The tutorial directory should also include a ``summary.md`` file at
top-level (so next to the ``tutorial.md`` file).  It should start with
a screenshot image, created along the lines of::

  ![Screenshot](summary-screenshot.png)

and after that should have a H1 line, such as::

  # Boing — a Pong-like game

and after that is free-form, but should be kept fairly short.  One
paragraph of a few lines is enough.


Output from compiler
--------------------

Zipfile containing a single directory at top level, whose name is
taken from the sole directoy at top-level in the repo (as of the tip
of the branch containing that particular tutorial).  Within that
directory, the contents are:

* ``tutorial.html`` — HTML fragment suitable for loading by
  interactive tutorial mechanism in webapp.

* ``project-assets/`` — Directory containing images and/or sounds as
  required by project which the tutorial explains.  Within the
  tutorial Python, the URL is taken to refer to an object under
  ``project-assets/``.  TODO: Need some magic to set the base-url for
  the project.  Currently that’s a Skulpt-level config option; should
  it be a piece of project state (don’t think so)?  The directory
  structure in the git repo should likewise have a ‘project-assets’
  directory.

TODO: What about assets for use in the tutorial itself, e.g.,
screenshots?  Can right-click on stage and choose ‘Save image as…’ (in
Chrome anyway); choosing this gives you a ``download.png`` file.
Might be nice to automatically generate screenshots by running the
script in true Python and capturing and enacting the rendering
instructions after a specified sequence of events, but that can be
future work.  Put these in ``tutorial-assets/`` both in the repo and
the output zipfile.

TODO: This information is independent of the fact that the zipfile
came from a git repo.  Move it to the general
``tutorial-structure.rst`` file?


Tool support
------------

TODO: Script to create git repo of appropriate form.  E.g., make
empty-base branch, initial commit within nothing in it, structure with
READMEs in appropriate directories (assets), initial ``tutorial.md``
with the title as given on command line.  Cookie-cutter for this?
Branch pointing at git history once those pieces are all committed?


Internals
---------

The following is cut/paste from an earlier version of the tool and
needs revising:

We collect the tutorial into chapters; each chapter is a list of
elements.  An 'interactive patch' element gets turned into a DIV with
the relevant patch as a table, as well as extra metadata.  Each
chapter starts with an H2 and continues until either the next H2 or
the end of the whole document.


Outline design
--------------

Major pieces are:

.. py:class:: Asset

    Graphics or sound asset belonging to project

    Distinction is (or will be) against *tutorial* asset, e.g., a
    screenshot to be included in the presentation.

    Contains path (QN: relative to what?) and data-bytes.  Relative to
    git root?

.. py:class:: ProjectCommit

    Individual commit from history

    Construct from repo and commit-OID.

    Different types of commit:

    - Identified commit belonging to project being developed: Expect
      this to be used in tutorial.
    - Addition of asset/s: E.g., adding a graphics file.
    - The unique base commit: How much code should there be in this?
      Just the ``import`` stuff at the top?
    - Updates just to the raw markdown of the tutorial text: Ignored
      when generating tutorial.
    - TODO: Addition of tutorial assets, e.g., screenshots.

    .. py:attribute:: added_assets

        A list of :py:class:`Asset` instances.

        QN: A given ProjectCommit might add more than one asset.  We
        also have an explicit (but possibly redundant) tag in the
        commit message to flag a commit as adding assets.  What if the
        tag and the actual commit disagree?  Should it be possible to
        do :py:attr:`added_assets` on any :py:class:`ProjectCommit`?
        Should this return an empty list if there are no added assets?
        Emit a warning if it adds assets but doesn't include the
        ``add-project-assets`` tag (or vice versa)?  TODO: That tag is
        no longer used I think?

    .. py:attribute:: maybe_identifying_slug

        The text of the identifying slug, if one present, otherwise None.

    .. py:attribute:: is_base: bool

        Whether the commit message contains the magic 'this is the base' tag.

    .. py:attribute:: modified_tutorial_text

        Whether the commit updates just the
        :samp:`{TOP-LEVEL-DIRECTORY}/tutorial.md` file, and is not
        otherwise tagged.


.. py:class:: ProjectHistory

    Chain of git commits developing project from scratch.

    Read in repo, starting at some commit and tracing back through
    first parent until a given end commit.  Really just a list of
    `ProjectCommit` objects.

    Ctor inputs:

    - Repo directory.  Branch name with latest commit in history to
      process.  (QN: Might one day want to support more than one
      'final' branch, to support 'now you try this', or 'alternatively
      we could have implemented this feature like this.)

    - Tip revision.

    - Which source to use for the tutorial text.


.. py:class:: TutorialRawText

    Document with tutorial text and DIVs for rich content

    Read in tutorial text, break down into sections, identify pieces
    where augmentation from the git repo is required.

    Ctor inputs:

    - Filename of markdown file.

    Representation:

    Soup?  Whose job is it to manipulate the soup to add the
    attributes etc. to the DIVs for interactive commits?  And who owns
    the soup?  Probably OK for it to live in the TutorialRawText, but
    for the convention to be that when that TutorialRawText is handed
    over to the TutorialBundle ctor, the contained soup is available
    for the TutorialBundle to mutate.

.. py:class:: TutorialBundle

    Filesystem fragment (tutorial.html, assets/ directory)

    Representation of everything needed to emit the tutorial bundle:

    - Raw text (`TutorialRawText`)
    - Git repo / project history (:py:class:`ProjectHistory`)

    Constructed from the above two things.

    .. py:method:: write_new_zipfile(file_or_filename)

    .. py:method:: write_to_zipfile(existing_open_zipfile)



TODOs
-----

Validation and/or warnings would be nice, including:

* each project asset is added once and then left alone
* each project asset has a path within the 'project-assets/' directory
* exactly those commits tagged as adding project assets do in fact add project assets
* all changes to the code file are tagged with identifier-slugs
* all untagged commits are changes to the tutorial.md file
* there is exactly one base in the history
* the history has no merges
